# -*- coding: utf-8 -*-
"""Convertisseur_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xuDDpBqFhMbUWQg-6QDhPIKA2tPa4Q1z
"""

pip install openpyxl

pip install pandas

import pandas as pd

# Charger les données du fichier classeur_type (.xls)
path_classeur_type = "/content/import_cnrs_exemple.xls"
classeur_type = pd.read_excel(path_classeur_type)

# Charger le classeur (.xlsx)
path_classeur = "/content/FICHE_DE_RENSEIGNEMENTS2024-01-26_06_14_46.xlsx"
feuille_classeur = pd.read_excel(path_classeur, engine='openpyxl')

"""la suite rahi lta7t pour le plan B

"""

# Afficher les premières lignes du dataframe classeur_type
print("Contenu du dataframe classeur_type:")
print(classeur_type.head())

# Afficher les premières lignes du dataframe feuille_classeur
print("\nContenu du dataframe feuille_classeur:")
print(feuille_classeur.head())

# Enregistrer les deux premières lignes de classeur_type dans un vecteur
deux_premieres_lignes = classeur_type.iloc[:2].values.tolist()

# Ajouter les deux premières lignes de classeur_type au début de feuille_classeur
feuille_classeur = pd.DataFrame(deux_premieres_lignes + feuille_classeur.values.tolist(), columns=classeur_type.columns)

# Afficher le résultat
print("Feuille_classeur après ajout des deux premières lignes et réorganisation des colonnes :")
print(feuille_classeur.head())

# Enregistrer les noms de colonnes de feuille_classeur
noms_colonnes = feuille_classeur.columns.tolist()

# Enregistrer les deux premières lignes de classeur_type dans un vecteur
deux_premieres_lignes = classeur_type.iloc[:2].values.tolist()

# Ajouter les deux premières lignes de classeur_type au début de feuille_classeur
feuille_classeur = pd.DataFrame(deux_premieres_lignes + feuille_classeur.values.tolist(), columns=classeur_type.columns)

# Réorganiser les colonnes de feuille_classeur pour correspondre à l'ordre de classeur_type
feuille_classeur = feuille_classeur[classeur_type.columns]

# Réinsérer les noms de colonnes dans la ligne 3
feuille_classeur.iloc[2] = noms_colonnes

# Afficher le résultat
print("Feuille_classeur après ajout des deux premières lignes et réorganisation des colonnes :")
print(feuille_classeur.head())

# Afficher la structure de feuille_classeur
print("Nombre de lignes et de colonnes de feuille_classeur :")
print(feuille_classeur.shape)

# Afficher les noms de colonnes de feuille_classeur
print("Noms de colonnes de feuille_classeur :")
print(feuille_classeur.columns)

# Afficher les noms de colonnes de feuille_classeur
print("Noms de colonnes de classeur_type :")
print(classeur_type.columns)

print(feuille_classeur.tail())

# Afficher le nombre de colonnes pour chaque ligne de feuille_classeur
nombre_colonnes_par_ligne = feuille_classeur.apply(lambda row: row.count(), axis=1)

# Afficher le résultat
print("Nombre de colonnes pour chaque ligne de feuille_classeur :")
print(nombre_colonnes_par_ligne)

# Afficher les données des lignes 4 à 6
donnees_lignes_4_a_6 = feuille_classeur.iloc[3:7]
print("Données des lignes 4 à 6 de feuille_classeur :")
print(donnees_lignes_4_a_6)

import pandas as pd

# Charger les données de classeur_type
path_classeur_type = "/content/import_cnrs_exemple.xls"
classeur_type = pd.read_excel(path_classeur_type, header=[0, 1])

# Charger les données de feuille_classeur
path_feuille_classeur = "/content/FICHE_DE_RENSEIGNEMENTS2024-01-26_06_14_46.xlsx"
feuille_classeur = pd.read_excel(path_feuille_classeur, header=[0, 1])

# Trouver la première ligne avec 32 colonnes dans feuille_classeur
index_ligne_32_colonnes = feuille_classeur.index[feuille_classeur.apply(lambda row: row.count().sum() == 32, axis=1)].tolist()[0]

# Ajouter les colonnes manquantes à partir de la ligne 32 (à l'index 3)
feuille_classeur = pd.concat([feuille_classeur.iloc[:index_ligne_32_colonnes + 1],
                              pd.DataFrame(columns=classeur_type.columns, index=range(len(feuille_classeur) - index_ligne_32_colonnes - 1)),
                              feuille_classeur.iloc[index_ligne_32_colonnes + 1:]])

# Trier les colonnes selon l'ordre de classeur_type
feuille_classeur = feuille_classeur.sort_index(axis=1, level=[0, 1])

# Afficher le résultat final
print("Feuille_classeur après la modification de la structure :")
print(feuille_classeur.head)

print(classeur_type.head)

import pandas as pd

# Charger les données de classeur_type
path_classeur_type = "/content/import_cnrs_exemple.xls"
classeur_type = pd.read_excel(path_classeur_type, header=[0, 1])

# Charger les données de feuille_classeur
path_feuille_classeur = "/content/FICHE_DE_RENSEIGNEMENTS2024-01-26_06_14_46.xlsx"
feuille_classeur = pd.read_excel(path_feuille_classeur, header=[0, 1])

# Afficher les colonnes des deux DataFrames avant la modification
print("Colonnes de classeur_type avant la modification :")
print(classeur_type.columns)

print("\nColonnes de feuille_classeur avant la modification :")
print(feuille_classeur.columns)

# Trouver la première ligne avec 32 colonnes dans feuille_classeur
index_ligne_32_colonnes = feuille_classeur.index[feuille_classeur.apply(lambda row: row.count().sum() == 32, axis=1)].tolist()[0]

# Ajouter les colonnes manquantes à partir de la ligne 32 (à l'index 3)
feuille_classeur = pd.concat([feuille_classeur.iloc[:index_ligne_32_colonnes + 1],
                              pd.DataFrame(columns=classeur_type.columns, index=range(len(feuille_classeur) - index_ligne_32_colonnes - 1)),
                              feuille_classeur.iloc[index_ligne_32_colonnes + 1:]])

# Afficher les colonnes des deux DataFrames après la modification
print("\nColonnes de classeur_type après la modification :")
print(classeur_type.columns)

print("\nColonnes de feuille_classeur après la modification :")
print(feuille_classeur.columns)

# Trier les colonnes selon l'ordre de classeur_type
feuille_classeur = feuille_classeur.sort_index(axis=1, level=[0, 1])

# Réinitialiser l'index de feuille_classeur
feuille_classeur = feuille_classeur.reset_index(drop=True)

# Afficher le résultat final
print("\nFeuille_classeur après la modification de la structure :")
print(feuille_classeur)

import pandas as pd

# Supposons que votre feuille_classeur modifiée est stockée dans une variable appelée "feuille_classeur_modifiee"

# Convertissez les colonnes MultiIndex en un format de colonnes simple
feuille_classeur.columns = [' '.join(map(str, col)).strip() for col in feuille_classeur.columns.values]

# Enregistrez le DataFrame dans un fichier Excel
feuille_classeur.to_excel('/content/nom_du_fichier.xlsx', index=False)

import pandas as pd

# Chargez le fichier Excel modifié
feuille_classeur_modifiee = pd.read_excel('/content/nom_du_fichier.xlsx')

# Convertissez les colonnes MultiIndex en un format de colonnes simple
feuille_classeur_modifiee.columns = [' '.join(map(str, col)).strip() for col in feuille_classeur_modifiee.columns.values]

# Enregistrez le DataFrame dans un fichier Excel
feuille_classeur_modifiee.to_excel('/content/nouveau_nom_du_fichier.xlsx', index=False)

"""Plan B"""

# Afficher les noms de colonnes avec leurs indices pour le classeur_type depuis la ligne 3
print("=== Classeur Type ===")
for idx, colname in enumerate(classeur_type.iloc[1]):
    print(f"{colname}: {idx}")

# Afficher les noms de colonnes avec leurs indices pour le feuille_classeur
print("\n=== Feuille Classeur ===")
for idx, colname in enumerate(feuille_classeur.columns):
    print(f"{colname}: {idx}")

import pandas as pd

# Charger les données du fichier classeur_type (.xls)
path_classeur_type = "/content/import_cnrs_exemple.xls"
classeur_type = pd.read_excel(path_classeur_type, header=2)  # Utiliser la ligne 3 comme en-tête

# Charger le classeur (.xlsx)
path_classeur = "/content/FICHE_DE_RENSEIGNEMENTS2024-01-26_06_14_46.xlsx"
feuille_classeur = pd.read_excel(path_classeur, engine='openpyxl')

# Ajouter les colonnes manquantes à feuille_classeur
colonnes_manquantes = set(classeur_type.columns) - set(feuille_classeur.columns)
for colonne in colonnes_manquantes:
    feuille_classeur[colonne] = None  # Vous pouvez remplacer None par la valeur que vous souhaitez

# Réorganiser les colonnes en fonction de l'ordre de classeur_type
feuille_classeur = feuille_classeur[classeur_type.columns]

# Afficher les colonnes de la feuille_classeur après l'ajout et la réorganisation
print("=== Feuille Classeur après l'ajout et la réorganisation ===")
for idx, colname in enumerate(feuille_classeur.columns):
    print(f"{colname}: {idx}")

# Afficher les premières lignes du DataFrame feuille_classeur après les modifications
print(feuille_classeur.head())

# Dupliquer les colonnes de feuille_classeur pour avoir 3 lignes supplémentaires
feuille_classeur_temp = pd.concat([feuille_classeur] * 3, ignore_index=True)

# Ajouter les deux lignes au début de feuille_classeur
feuille_classeur = pd.concat([feuille_classeur_temp, feuille_classeur], ignore_index=True)

# Réorganiser les colonnes de feuille_classeur
feuille_classeur = feuille_classeur[classeur_type.columns]

# Afficher les premières lignes du DataFrame mis à jour
print(feuille_classeur.head())

print(feuille_classeur['Date de naissance (jj/mm/aaaa)'])

# Importer la bibliothèque datetime
from datetime import datetime

# Fonction pour convertir le format de date de feuille_classeur à celui de classeur_type
def convertir_date(row):
    mois_fr_to_en = {'janv.': '01', 'févr.': '02', 'mars': '03', 'avr.': '04', 'mai': '05', 'juin': '06',
                     'juil.': '07', 'août': '08', 'sept.': '09', 'oct.': '10', 'nov.': '11', 'déc.': '12'}
    try:
        date_fr = row['Date de naissance (jj/mm/aaaa)']
        if pd.notna(date_fr):
            parts = date_fr.split(' ')
            mois_en = mois_fr_to_en[parts[0]]
            date_en = f"{mois_en}/{parts[1][:-1]}/{parts[2]}"
            return datetime.strptime(date_en, '%m/%d/%Y')
    except:
        pass
    return pd.NaT

# Appliquer la fonction de conversion sur la colonne 'Date de naissance (jj/mm/aaaa)'
feuille_classeur['Date de naissance (jj/mm/aaaa)'] = feuille_classeur.apply(convertir_date, axis=1)

# Afficher le résultat
print(feuille_classeur['Date de naissance (jj/mm/aaaa)'])

# Reformater les dates au format jj/mm/aaaa
feuille_classeur['Date de naissance (jj/mm/aaaa)'] = feuille_classeur['Date de naissance (jj/mm/aaaa)'].dt.strftime('%d/%m/%Y')

# Afficher le résultat
print(feuille_classeur['Date de naissance (jj/mm/aaaa)'])

print(feuille_classeur['Date de décès'])

# Fonction pour convertir le format de date de décès de feuille_classeur à celui de classeur_type
def convertir_date(row):
    mois_fr_to_en = {'janv.': '01', 'févr.': '02', 'mars': '03', 'avr.': '04', 'mai': '05', 'juin': '06',
                     'juil.': '07', 'août': '08', 'sept.': '09', 'oct.': '10', 'nov.': '11', 'déc.': '12'}
    try:
        date_fr = row['Date de décès']
        if pd.notna(date_fr):
            parts = date_fr.split(' ')
            mois_en = mois_fr_to_en[parts[0]]
            date_en = f"{mois_en}/{parts[1][:-1]}/{parts[2]}"
            return datetime.strptime(date_en, '%m/%d/%Y')
    except:
        pass
    return pd.NaT

# Appliquer la fonction de conversion sur la colonne 'Date de décès'
feuille_classeur['Date de décès'] = feuille_classeur.apply(convertir_date, axis=1)


# Reformater les dates au format jj/mm/aaaa
feuille_classeur['Date de décès'] = feuille_classeur['Date de décès'].dt.strftime('%d/%m/%Y')
# Afficher le résultat
print(feuille_classeur['Date de décès'])

# Remplacer les valeurs NaN par '00/00/0000'
feuille_classeur['Date de décès'] = feuille_classeur['Date de décès'].fillna('00/00/0000')

# Afficher le résultat
print(feuille_classeur['Date de décès'])

def filtrer_puces(df):
    # Filtrer les lignes en fonction du nombre de chiffres dans la colonne 'puce'
    df['puce'] = df['puce'].astype(str)  # Assurer que la colonne est de type str pour compter les chiffres
    df['nombre_chiffres'] = df['puce'].apply(lambda x: sum(c.isdigit() for c in x))  # Compter le nombre de chiffres dans chaque valeur

    # Filtrer les lignes où le nombre de chiffres est égal à 15
    df_filtré = df[df['nombre_chiffres'] == 15].copy()

    # Supprimer la colonne temporaire 'nombre_chiffres'
    df_filtré.drop('nombre_chiffres', axis=1, inplace=True)

    return df_filtré

# Appeler la fonction avec votre DataFrame
feuille_classeur_filtre = filtrer_puces(feuille_classeur).reset_index(drop=True)  # Réinitialiser les index

# Afficher le résultat
print(feuille_classeur_filtre['puce'])

# Supprimer le contenu des colonnes 'Décès' et 'Date de Décès'
feuille_classeur_filtre['Décès'] = ''
feuille_classeur_filtre['Date de Décès'] = ''

# Afficher le DataFrame mis à jour
print(feuille_classeur_filtre['Décès'])

# Enregistrez le DataFrame dans un fichier Excel
feuille_classeur_filtre.to_excel('/content/try.xlsx', index=False)
